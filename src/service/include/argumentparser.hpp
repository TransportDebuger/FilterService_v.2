/**
 * @file argumentparser.hpp
 * @author Artem Ulyanov
 * @company STC Ltd.
 * @date May 2025
 * @brief Парсер аргументов командной строки
 *
 * @details
 * Модуль предоставляет функциональность для разбора и валидации аргументов
 * командной строки приложения XML Filter Service. Реализует паттерн "Command
 * Pattern" для обработки различных типов параметров и их валидации.
 *
 * Ключевые особенности реализации:
 * - Поддержка именованных параметров с и без значений
 * - Валидация типов логгеров и уровней логирования
 * - Обработка переопределений конфигурации через CLI
 * - Механизм приоритетов: CLI параметры переопределяют настройки файла
 * конфигурации
 * - Полная поддержка справочной информации
 *
 * Используемые паттерны:
 * - Parser Pattern для разбора аргументов
 * - Strategy Pattern для различных методов парсинга
 * - Validation Pattern для проверки корректности параметров
 *
 * @version 1.0
 * @since 1.0
 */

#pragma once
#include <optional>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

/**
 * @struct ParsedArgs
 * @brief Структура для хранения результатов парсинга аргументов командной
 * строки
 *
 * @details
 * Содержит все параметры, полученные из командной строки после их обработки и
 * валидации. Используется как контейнер для передачи конфигурации между
 * компонентами системы. Все поля (за исключением опциональных) имеют значения
 * по умолчанию для обеспечения корректной работы при отсутствии соответствующих
 * параметров в командной строке.
 *
 * @note Структура является POD (Plain Old Data) для обеспечения эффективного
 * копирования
 * @warning Изменение порядка полей может нарушить совместимость с существующим
 * кодом
 */
struct ParsedArgs {
  /**
   * @brief Путь к файлу конфигурации
   * @details Указывает на JSON-файл с настройками сервиса.
   * Может быть относительным или абсолютным путем.
   * Значение по умолчанию: "/etc/stc/xmlfilter/config.json"
   */
  std::string config_path = "/etc/stc/xmlfilter/config.json";

  /**
   * @brief Карта переопределений параметров конфигурации
   * @details Содержит пары ключ-значение для замены параметров из файла
   * конфигурации. Формат ключа: "section.parameter" или "parameter" для
   * корневых параметров. Применяется после загрузки основной конфигурации.
   */
  std::unordered_map<std::string, std::string> overrides;

  /**
   * @brief Список типов логгеров для инициализации
   * @details Определяет, какие типы логгеров должны быть активированы.
   * Поддерживаемые значения: "console", "sync_file", "async_file"
   * Пустой список означает использование конфигурации из файла.
   */
  std::vector<std::string> logger_types;

  /**
   * @brief Уровень логирования (опциональный)
   * @details Переопределяет уровень логирования для всех активных логгеров.
   * Поддерживаемые значения: "debug", "info", "warning", "error", "critical"
   * Отсутствие значения означает использование индивидуальных настроек логгеров
   * из конфигурационного файла.
   */
  std::optional<std::string> log_level;

  /**
   * @brief Флаг запуска в режиме демона
   * @details При значении true приложение будет запущено как системный демон
   * с отключением от терминала и перенаправлением стандартных потоков.
   * Значение по умолчанию: false
   */
  bool daemon_mode = false;

  /**
   * @brief Флаг предоставления help сообщения
   * @details При значении true приложение выведет в консоль сообщение 
   * с подсказкой по аргументам командной строки.
   * Значение по умолчанию false.
   */
  bool help_message = false;

  /**
   * @brief Флаг предоставления сообщения о версии программного обеспечения
   * @details При значении true приложение выведет в консоль сообщение
   * о версии программного обеспечения.
   * Значение по умолчанию false.
   */
  bool version_message = false;

  /**
   * @brief Флаг перезапуска работающего сервиса.
   * @details При значении true приложение генерирует системный сигнал SUGHUP
   * для перезагрузки работающего сервиса. Если сервис не работает, то ничего 
   * не происходит.
   * Значение по умолчанию false.
   */
  bool reload = false;

  /**
   * @brief Идентификатор окружения для выбора конфигурации
   * @details Определяет, какая секция конфигурации будет использована.
   * Поддерживаемые значения: "development", "production", "testing"
   * Значение по умолчанию: "production"
   */
  std::string environment = "production";

  /**
   * @brief Флаг использования CLI параметров для логирования
   * @details Указывает, были ли заданы параметры логирования через командную
   * строку. При значении true игнорируется секция логирования из файла
   * конфигурации. Устанавливается автоматически при обработке --log-type или
   * --log-level.
   */
  bool use_cli_logging = false;
};

/**
 * @defgroup CLI Компоненты разбора CLI
 */

/**
 * @defgroup MainAPI Основные методы
 */

/**
 * @defgroup ParsingMethods Методы разбора параметров командной строки
 */

/**
 * @defgroup ValidationMethods Методы валидации данных
 */

/**
 * @defgroup UtilityMethods Вспомогательные методы
 */

/**
 * @class ArgumentParser
 * @brief Парсер аргументов командной строки
 * @ingroup CLI
 *
 * @details
 * Класс предоставляет функциональность для разбора, валидации и обработки
 * аргументов командной строки. Поддерживает различные форматы параметров,
 * включая короткие и длинные опции, параметры с обязательными и опциональными
 * значениями, а также специальные команды справки.
 *
 * Основные возможности:
 * - Парсинг именованных параметров в формате --parameter=value или --parameter
 * value
 * - Валидация типов логгеров и уровней логирования
 * - Обработка списков значений (например, типов логгеров через запятую)
 * - Поддержка переопределений конфигурации в формате ключ:значение
 * - Вывод справочной информации
 *
 * @note Класс не является потокобезопасным и предназначен для однократного
 * использования
 * @warning Исключения могут быть сгенерированы при некорректных аргументах
 *
 * @see ParsedArgs
 * @since 1.0
 */
class ArgumentParser {
 public:
  /**
     * @brief Парсит аргументы командной строки
     * @ingroup MainAPI
     *
     * @details
     * Основной метод класса, выполняющий полный цикл обработки аргументов:
     * разбор, валидацию и формирование результирующей структуры.
     * Поддерживает все стандартные форматы параметров POSIX и GNU.
     *
     * Поддерживаемые параметры:
     * - --help, -h: вывод справки и завершение программы
     * - --config-file=PATH: путь к файлу конфигурации
     * - --log-type=TYPE1,TYPE2: типы логгеров через запятую
     * - --log-level=LEVEL: уровень логирования
     * - --daemon: запуск в режиме демона
     * - --environment=ENV: выбор окружения
     * - --override=key:value: переопределение параметров конфигурации
     *
     * @param[in] argc Количество аргументов командной строки
     * @param[in] argv Массив строк аргументов
     * @return ParsedArgs Структура с результатами парсинга
     *
     * @throw std::invalid_argument При некорректных аргументах или их значениях
     * @throw std::runtime_error При системных ошибках обработки
     *
     * @note Метод может завершить программу вызовом exit() при использовании
     --help
     * @warning argc должно быть >= 1, argv[0] должен содержать имя программы
     *
     * @code
     // Пример вызова
     ArgumentParser parser;
     ParsedArgs args = parser.parse(argc, argv);

     // Использование результатов
     if (args.daemon_mode) {
         // Запуск в режиме демона
     }
     if (!args.logger_types.empty()) {
         // Инициализация указанных логгеров
     }
     @endcode
     */
  ParsedArgs parse(int argc, char **argv);

 private:
  /**
   * @brief Список допустимых уровней логирования
   * @details Содержит все поддерживаемые системой уровни логирования
   * в порядке возрастания критичности. Используется для валидации
   * параметра --log-level.
   */
  static const std::vector<std::string> validLogLevels;

  /**
   * @brief Список допустимых типов логгеров
   * @details Содержит все поддерживаемые системой типы логгеров.
   * Используется для валидации параметра --log-type.
   */
  static const std::vector<std::string> validLogTypes;

  /**
     * @brief Обрабатывает параметр переопределения конфигурации
     * @ingroup ParsingMethods
     *
     * @details
     * Парсит параметр --override в формате key:value и добавляет
     * результат в карту переопределений. Поддерживает вложенные ключи
     * через точечную нотацию (например, "database.host:localhost").
     *
     * @param[in] arg Строка аргумента для обработки
     * @param[in,out] args Структура для сохранения результата
     *
     * @throw std::invalid_argument При некорректном формате параметра
     *
     * @note Формат: --override=section.key:value или --override=key:value
     * @warning Пустые ключи или значения не допускаются
     *
     * @code
     // Пример корректного использования:
     --override=database.port:5432
     --override=debug_mode:true
     @endcode
     */
  void parseOverride(const std::string &arg, ParsedArgs &args);

  /**
     * @brief Обрабатывает параметр типов логгеров
     * @ingroup ParsingMethods
     *
     * @details
     * Парсит параметр --log-type, который может содержать один или несколько
     * типов логгеров, разделенных запятыми. Выполняет валидацию каждого типа
     * и устанавливает флаг использования CLI логирования.
     *
     * @param[in] arg Строка аргумента для обработки
     * @param[in,out] args Структура для сохранения результата
     * @param[in,out] i Текущий индекс в массиве аргументов
     * @param[in] argc Общее количество аргументов
     * @param[in] argv Массив аргументов
     *
     * @throw std::invalid_argument При некорректном типе логгера или отсутствии
     значения
     *
     * @note Поддерживаемые форматы: --log-type=console или --log-type console
     * @warning Автоматически устанавливает use_cli_logging = true
     *
     * @code
     // Примеры корректного использования:
     --log-type=console
     --log-type=console,async_file
     --log-type console,sync_file
     @endcode
     */
  void parseLogType(const std::string &arg, ParsedArgs &args, int &i, int argc,
                    char **argv);

  /**
     * @brief Обрабатывает параметр пути к файлу конфигурации
     * @ingroup ParsingMethods
     *
     * @details
     * Парсит параметр --config-file и сохраняет путь к файлу конфигурации.
     * Поддерживает как относительные, так и абсолютные пути.
     * Не выполняет проверку существования файла на этапе парсинга.
     *
     * @param[in] arg Строка аргумента для обработки
     * @param[in,out] args Структура для сохранения результата
     * @param[in,out] i Текущий индекс в массиве аргументов
     * @param[in] argc Общее количество аргументов
     * @param[in] argv Массив аргументов
     *
     * @throw std::invalid_argument При отсутствии значения параметра
     *
     * @note Поддерживаемые форматы: --config-file=path или --config-file path
     * @warning Не выполняется валидация существования или доступности файла
     *
     * @code
     // Примеры корректного использования:
     --config-file=/etc/service/config.json
     --config-file=./local-config.json
     @endcode
     */
  void parseConfigFile(const std::string &arg, ParsedArgs &args, int &i,
                       int argc, char **argv);

  /**
     * @brief Обрабатывает параметр уровня логирования
     * @ingroup ParsingMethods
     *
     * @details
     * Парсит параметр --log-level и выполняет валидацию против списка
     * допустимых уровней. Устанавливает флаг использования CLI логирования.
     * Уровень применяется ко всем активным логгерам с наивысшим приоритетом.
     *
     * @param[in] arg Строка аргумента для обработки
     * @param[in,out] args Структура для сохранения результата
     * @param[in,out] i Текущий индекс в массиве аргументов
     * @param[in] argc Общее количество аргументов
     * @param[in] argv Массив аргументов
     *
     * @throw std::invalid_argument При некорректном уровне логирования или
     отсутствии значения
     *
     * @note Поддерживаемые форматы: --log-level=debug или --log-level debug
     * @warning Автоматически устанавливает use_cli_logging = true
     *
     * @code
     // Примеры корректного использования:
     --log-level=debug
     --log-level info
     --log-level error
     @endcode
     */
  void parseLogLevel(const std::string &arg, ParsedArgs &args, int &i, int argc,
                     char **argv);

  /**
     * @brief Валидирует список типов логгеров
     * @ingroup ValidationMethods
     *
     * @details
     * Проверяет, что все указанные типы логгеров поддерживаются системой.
     * Использует предопределенный список validLogTypes для сравнения.
     * Вызывается автоматически после парсинга всех аргументов.
     *
     * @param[in] types Вектор типов логгеров для проверки
     *
     * @throw std::invalid_argument При обнаружении неподдерживаемого типа
     *
     * @note Проверка выполняется для всех элементов вектора
     * @warning Метод не изменяет переданный вектор
     *
     * @code
     std::vector<std::string> types = {"console", "async_file"};
     validateLogTypes(types); // Успешно
     *
     types = {"console", "invalid_type"};
     validateLogTypes(types); // Генерирует исключение
     @endcode
     */
  void validateLogTypes(const std::vector<std::string> &types);
};